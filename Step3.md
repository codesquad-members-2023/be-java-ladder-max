# Step3. 사다리 구현 3단계 - 사다리 모양 개선
## 미션 구현
- [x] 이차원 배열 말로 List를 사용하도록 변경
- [x] 플레이어 이름을 입력받고 사다리와 같이 출력
- [x] 가로 라인이 겹치지 않도록 구현
- [x] mvc 패턴으로 패키지 나누기

## 학습한 내용
### 고민한 부분
1. 더이상 사용하지 않는 전 단계에 구현한 메서드들은 없애버려도 될까? 인터페이스를 만들어서 남겨놔야하나?
- 실무에서는 아마 인터페이스를 만드는 쪽으로 하지 않을까 싶었지만 앞으로 미션 구현할 때 쓸모 없을 것 같아서 없애버렸다.

2. 이름이 문자인것은 중첩 for문을 돌리는 방법밖에 없을까?
- 정규식을 사용해보자! 
- 어차피 모든 이름의 모든 부분이 알파벳이어야 하므로 모든 이름을 하나의 String으로 만들어서 정규식 검사를 하면 for문을 돌리지 않아도 된다.

3. User 관련한 클래스를 따로 만들어야 할까?
- List<String>으로 사용자의 이름을 받아오는 것이 다라서 아직은 클래스를 분리하지 않아도 될 것 같다.
- 그렇지만 이 자료구조가 유저의 이름들을 담고 있다는 것을 명시하는 용도로 사용하는 것은 괜찮을지도

4. makeLadder의 flow는?
- 먼저, 유저의 이름들을 사다리의 맨 위에 넣는다. 이때, 한 사다리 위에 유저의 이름이 들어갈 수 있게 공백이 들어가는 부분은 (6 - 이름길이)만큼 공백을 넣는다.
  - 6에서 빼는 이유는 사다리의 가로라인 사이즈(5)에 이름의 첫 글자가 시작하는 세로라인(1)을 합하면 6이기 때문
- length만큼 사다리의 행을 만들어준다.
- 사다리의 열을 넣을 때 맨 먼저 |을 넣는다.
- 이전 가로사다리가 어떤 모양인지에 따라 현재 가로사다리의 모양을 결정한다.
- 결정한 모양을 list에 넣고 |도 리스트에 넣는다.
- 사다리에 완성된 리스트 하나(행 하나)를 넣는다.

5. 문자가 여러 개 있고 사이에 공백이나 개행문자를 넣고 싶은데 어떻게 하는 것이 효율적일까
- 일단 문자를 저장하고 바로 공백이나 개행문자도 저장한 수 for문이 끝나면 마지막 공백이나 개행문자를 삭제하는 방식으로 구현했다.
- 더 좋은 방법이 있는지 팀원들에게 물어봐야겠다.

6. 하드코딩의 정확한 범위는?
- 초기화를 위한 String str = ""; 이런 것도 상수로 만들어야 하는지
- 인덱스를 설정하기 위한 숫자들도 상수로 만들어야 하는지
- 모르겠다!

### LinkedList와 ArrayList
LinkedList와 ArrayList는 List 인터페이스를 구현한 Collection 구현체이며, 내부적으로는 다르게 동작한다.    

__List 인터페이스__
순서가 있는 집합을 처리하기 위한 인터페이스이기 때문에 인덱스가 있어 위치를 지정하여 값을 찾을 수 있다. 중복을 허용한다는 특징을 가진다. 두 개의 ArrayList와 LinkedList 구현체가 있으며, 원조격으로 Vector 구현체가 있다.

__ArrayList__    

ArrayList는 내부적으로 데이터를 배열에서 관리한다. 데이터의 추가, 삭제를 위해 임시 배열을 생성해 데이터를 복사하는 방법을 사용한다.    

따라서 대량의 데이터를 추가, 삭제하는 경우 성능 저하가 일어날 수 있어 사용하지 않는 편이 좋다. 각 데이터는 인덱스를 가지고 있어 한 번에 참조가 가능하기 때문에 검색을 많이 할 때는 좋은 성능을 낼 수 있다.    

검색 시 O(1)의 시간 복잡도를 가진다.    

데이터의 삽입, 삭제 시 이후 다른 데이터를 복사해야 하기 때문에 O(n)의 시간 복잡도를 가진다.    

__LinkedList__    

LinkedList는 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있다. 데이터의 추가, 삭제를 위해 데이터를 복사하지 않아 이 경우에는 성능이 좋지만, 검색 시에는 처음부터 노드를 순회해야 하기 때문에 성능이 좋지 않다.    

검색 시 O(n)의 시간 복잡도를 가진다.    

데이터의 삽입 삭제 시 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되기 때문에 O(1)의 시간 복잡도를 가진다.    

### BufferedReader는 언제 닫아주는 것이 좋은가
BufferedReader는 사용할 때 자원을 사용하는데 여러 사용자가 한 번에 접근하면 동시성 문제가 생기지 않을까?란 생각이 들었다.    
찾아보니 BufferedReader는 동기화되기 때문에 멀티쓰레드 환경에서 안전하다고 한다.    
또한, 사용하지 않는 BufferedReader는 Garbage Collector가 자동으로 닫아주기 때문에 많이 신경쓰지 않아도 될 것 같다.

## 구현 결과
![ex1](https://user-images.githubusercontent.com/57451700/223782249-70b86ded-1959-4d78-9242-a2c045c38996.png)    
![ex2](https://user-images.githubusercontent.com/57451700/223782269-69cfe9e7-0290-4342-b5bf-6a34e09655c2.png)    
![result1](https://user-images.githubusercontent.com/57451700/223782199-6df07087-888d-4090-a6c9-ce9d99ce3de1.png)    

## 팀원 피드백
### 차차
""나 1도 다 상수로 빼는 것이 좋다!
### June
StringBuilder 사용해서 출력할 때 마지막 인덱스 빼지말고 subString 사용하면 한번에 반환 가능    
user를 사다리에 넣지 않고 출력할 때 쓰는 방법도 있다.

### 지구(chatGPT)
LinkedList의 peek()와 poll() 메서드는 맨 앞(head) 요소에 접근하기 때문에, 요소를 찾아가는 작업이 필요하지 않다. 이 두 메서드는 O(1)의 시간 복잡도를 가진다.    
Encoding과 Validation 클래스가 Input과 Output을 위해서만 사용된다면 클래스를 하나로 합치던가 view 패키지 안으로 넣는게 좋을 것 같다.

## 추가로 공부할 부분
1. Pattern, Matcher 클래스의 차이
2. else를 왜 쓰면 안되는가
3. generic
4. rebase, merge 차이 및 활용 사례
5. 값에 의한 호출, 참조에 의한 호출

## 참고
[[Java] 빠른 입출력을 위한 BufferedReader, BufferedWriter, StringTokenizer, StringBuilder](https://rlakuku-program.tistory.com/33)