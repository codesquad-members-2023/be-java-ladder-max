# Step 5. 사다리 구현 5단계 - 실행결과 출력
## 학습 계획
- [ ] step5 구현
- [x] 클래스 분리
- [ ] Generic 학습
- [ ] JCF 학습
- [ ] 깃 학습     


## 미션 구현
- [x] step4 피드백 받은 내용을 토대로 수정
  - 변수명 제대로 짓기
- [ ] 실행 결과 입력하기
- [ ] 게임 실행하기
  - 세로선이면 다음 행으로 넘어가기
  - 현재위치 +1 또는 현재위치 -1 에 가로선이 있으면 해당 방향으로 이동하기
  - 다 탐색하면 플레이어 이름과 결과 인덱스를 List<List<>>로 반환
- [ ] 결과 확인하기
  - 결과를 Map<이름, 결과> 로 반환
  - 개인 보여주기
    - Map에서 이름에 해당하는 값을 Map으로 반환
  - 전체 보여주기
    - Map 반환
- [ ] 결과 인코딩
  - Map으로 받은 것을 String으로 변환하여 반환
- [ ] 결과 출력하기
- [ ] 게임 반복하기
  - 종료 조건: '춘식이' 입력

## 고민한 부분
### 클래스 분리
view와 Controller 부분을 명확하게 분리하기 위해 LadderGame이라는 상위 클래스를 만들고, 그 안에서 view와 Controller를 생성했다.    
멤버변수는 적을수록 좋다는 것과 view는 객체를 만들지 않아도 된다는 점 때문에
view의 메서드들은 다 static으로 선언했다.    
input의 validation을 어느 부분에 위치하게 해야 하나 고민을 했는데, validation을 통과해야만 Controller를 생성할 수 있게 Controller의 생성자에 위치시켰다.    
여기서의 문제점은 Controller가 멤버변수(users, ladderHeight)를 가질 수밖에 없다는 점인데, 이것을 없애고 싶다면 생성자 안에서 메인 로직을 호출해야 한다.    
개인적으로 좋은 방법은 아니라고 생각하는데 팀원들의 생각을 한 번 물어보고 난 뒤 판단해야겠다.    
LadderGenerator에서 width 계산과 전체 사다리를 그리는 역할을 한다. 사다리의 행을 그리는 것은 Line에서 담당한다.    
사다리의 이전 가로부분이 공백인지 판단하는 메서드를 Enum 클래스의 메소드로 빼서 테스트하기 용이하게 만들었다.    
List<List<String>>이라는 형태는 직관적이지 않아서 Users, User 클래스로 분리했고, Encoding 클래스는 맡는 역할이 너무 작아서 도메인에 합쳐도 괜찮을 것 같아 show() 메서드로 만들었다.    
사다리에 사용자를 넣는 것은 사다리가 너무 많은 책임을 가지게 하는 것 같아서 Ladder에서는 사다리만 만들고 show할 때 사용자를 넣는 방식으로 바꿨다.


## 학습 내용


## 팀원 피드백
1. 공백인지 판단하는 메소드는 Enum 클래스로 빼는 것이 나은 것 같다.

